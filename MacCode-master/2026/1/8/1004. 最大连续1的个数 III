/*
给定一个二进制数组 nums 和一个整数 k，假设最多可以翻转 k 个 0 ，则返回执行操作后 数组中连续 1 的最大个数 。
示例 1：

输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：

输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。

*/
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) 
    {
        int left = 0, right = 0;
        int zeroCount = 0;  // 记录窗口中0的个数
        int maxLen = 0;
        
        // 使用滑动窗口
        while (right < nums.size()) 
        {
            // 扩大右边界
            if (nums[right] == 0) 
                zeroCount++;

            // 如果窗口中的0超过了k，需要缩小左边界
            while (zeroCount > k) 
            {
                if (nums[left] == 0) 
                    zeroCount--;
                left++;
            }
            
            // 更新最大长度
            maxLen = max(maxLen, right - left + 1);
            right++;
        }
        
        return maxLen;
    }
};